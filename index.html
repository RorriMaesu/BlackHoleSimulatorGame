<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Cosmic Sandbox</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .controls-panel {
            position: absolute;
            background: linear-gradient(145deg, rgba(23, 30, 46, 0.85), rgba(10, 15, 25, 0.85));
            padding: 1rem;
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            transition: opacity 0.4s ease, transform 0.4s ease, visibility 0.4s;
            max-height: calc(100vh - 2rem);
            display: flex;
            flex-direction: column;
        }
        #main-controls-container {
            top: 1rem;
            left: 1rem;
            width: 320px;
            max-width: calc(100vw - 2rem);
            z-index: 10;
        }
        #mass-editor-panel {
            top: 1rem;
            right: 1rem;
            width: 320px;
            max-width: calc(100vw - 2rem);
            z-index: 10;
        }
        #mass-editor-content {
            overflow-y: auto;
            padding-right: 0.5rem; /* For scrollbar spacing */
        }
        #collapsible-controls {
            max-height: 500px; /* Set a large max-height for open state and desktop */
            overflow: hidden;
            transition: max-height 0.5s ease-in-out, margin-top 0.5s ease-in-out;
        }
        #mobile-controls {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.4s ease;
        }
        #mobile-controls.visible {
            opacity: 1;
        }
        .joystick-container {
            width: 120px;
            height: 120px;
            position: relative;
            background-color: rgba(30, 41, 59, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: auto;
        }
        .joystick-handle {
            width: 60px;
            height: 60px;
            position: absolute;
            top: 50%;
            left: 50%;
            background-color: rgba(71, 85, 105, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255, 255, 255, 0.5);
        }
        #mobile-fire-button {
            width: 80px;
            height: 80px;
            background-color: #ef4444;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 1.25rem;
            border: 3px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(239, 68, 68, 0.7);
            pointer-events: auto;
            transition: transform 0.1s;
        }
        #mobile-fire-button:active {
            transform: scale(0.9);
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            border: 2px solid rgba(0, 255, 136, 0.7);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 4;
        }
        @media (max-width: 767px) {
            #mass-editor-panel {
                display: none; /* Hide mass editor on small screens for clarity */
            }
            #collapsible-controls.collapsed {
                max-height: 0;
                margin-top: 0 !important;
            }
        }
    </style>
</head>
<body class="bg-black">

    <!-- Left Controls Panel -->
    <div id="main-controls-container" class="controls-panel">
        <div class="flex justify-between items-center">
            <h1 class="text-xl font-bold">Cosmic Sandbox</h1>
            <button id="toggle-controls-btn" class="md:hidden p-2 bg-gray-700 rounded-lg text-white font-semibold">Hide</button>
        </div>
        <div id="collapsible-controls" class="mt-4">
            <div class="mb-3"><label for="gravity-slider" class="text-sm font-medium">Global Gravity</label><div class="flex items-center gap-2 mt-1"><input type="range" id="gravity-slider" min="0.1" max="1000" step="0.1" value="1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"><input type="number" id="gravity-input" min="0.1" step="0.1" value="1" class="w-20 bg-gray-800 border border-gray-600 text-white rounded-md p-1 text-center"></div></div>
            
            <!-- Projectile Selection -->
            <div class="mb-3">
                <label class="text-sm font-medium">Projectile Type</label>
                <!-- Mobile Selector -->
                <div class="md:hidden flex items-center justify-between mt-1">
                    <button id="prev-ammo-btn" class="px-4 py-2 bg-gray-700 rounded-lg text-lg font-bold">&lt;</button>
                    <span id="current-ammo-name" class="font-semibold text-center text-lg mx-2">Small Planet</span>
                    <button id="next-ammo-btn" class="px-4 py-2 bg-gray-700 rounded-lg text-lg font-bold">&gt;</button>
                </div>
                <!-- Desktop Selector -->
                <select id="ammo-select" class="w-full mt-1 p-2 bg-gray-800 border border-gray-600 rounded-md hidden md:block">
                    <option value="small-planet">Small Planet</option>
                    <option value="large-planet">Large Planet</option>
                    <option value="star">Star</option>
                    <option value="dwarf-star">Dwarf Star</option>
                    <option value="black-hole">Black Hole</option>
                </select>
            </div>

            <div class="mb-3"><label for="mass-slider" class="text-sm font-medium">Projectile Mass</label><div class="flex items-center gap-2 mt-1"><input type="range" id="mass-slider" min="1" max="50" step="1" value="5" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"><input type="number" id="mass-input" min="1" step="1" value="5" class="w-20 bg-gray-800 border border-gray-600 text-white rounded-md p-1 text-center"></div></div>

            <div class="mb-4"><label for="power-slider" class="text-sm font-medium">Launch Power</label><div class="flex items-center gap-2 mt-1"><input type="range" id="power-slider" min="10" max="1000" step="1" value="50" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer"><input type="number" id="power-input" min="10" step="1" value="50" class="w-20 bg-gray-800 border border-gray-600 text-white rounded-md p-1 text-center"></div></div>
            <p id="object-count-info" class="text-xs text-gray-400 mt-3">Objects: 0</p>
            <p id="controls-info" class="text-xs text-gray-400 mt-1">Click simulation to aim.</p>
        </div>
        <div class="flex flex-col md:flex-row gap-2 mt-4 pt-4 border-t border-gray-700">
            <button id="toggle-aim-mode-btn" class="md:hidden w-full p-2 bg-blue-600 rounded-lg text-white font-semibold">Aim</button>
            <button id="main-fire-btn" class="w-full p-2 bg-green-600 hover:bg-green-700 rounded-lg font-semibold transition-colors">FIRE</button>
            <button id="clear-btn" class="w-full p-2 bg-red-600 hover:bg-red-700 rounded-lg font-semibold transition-colors">Clear Scene</button>
        </div>
    </div>

    <!-- Right Mass Editor Panel -->
    <div id="mass-editor-panel" class="controls-panel">
        <h2 class="text-lg font-bold mb-2 flex-shrink-0">Object Mass Editor</h2>
        <div id="mass-editor-content" class="flex-grow"></div>
    </div>

    <!-- Mobile-only On-Screen Controls -->
    <div id="mobile-controls"><div id="joystick-move" class="joystick-container"><div class="joystick-handle"></div></div><div id="mobile-fire-button">FIRE</div><div id="joystick-aim" class="joystick-container"><div class="joystick-handle"></div></div></div>
    <div id="crosshair"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        const state = {isMobile: /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent), cameraMode: 'cinematic', keyState: {}, gravityConstant: 1.0, lastGravityConstant: 1.0, cannonPower: 50, canFire: true, recoilOffset: 0, objectIdCounter: 0};
        const objectTypes = {
            'small-planet': { name: 'Small Planet', radius: 1.5, color: 0x4a90e2, mass: 5, minMass: 1, maxMass: 50, emissiveIntensity: 0.4 },
            'large-planet': { name: 'Large Planet', radius: 3, color: 0x7ed321, mass: 20, minMass: 10, maxMass: 200, emissiveIntensity: 0.4 },
            'star': { name: 'Star', radius: 7, color: 0xffd700, mass: 200, minMass: 100, maxMass: 1000, isStar: true, emissiveIntensity: 1.2 },
            'dwarf-star': { name: 'Dwarf Star', radius: 4, color: 0xffffff, mass: 100, minMass: 50, maxMass: 500, isStar: true, emissiveIntensity: 1.0 },
            'black-hole': { name: 'Black Hole', radius: 5, color: 0x000000, mass: 50000, minMass: 10000, maxMass: 200000, isBlackHole: true, emissiveIntensity: 0 }
        };
        let blackHoles = [], celestialObjects = [], whiteHoles = [], transitionQueue = [];
        let cameraTarget;
        let currentOrbitRadius = 600;
        let targetOrbitRadius = 600;
        
        const scene = new THREE.Scene();
        const clock = new THREE.Clock();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const cinematicCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
        cinematicCamera.position.set(0, 150, 600);
        const cannonCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        let activeCamera = cinematicCamera;

        scene.add(new THREE.AmbientLight(0xffffff, 0.3));
        const pointLight = new THREE.PointLight(0xffffff, 2.5, 5000);
        scene.add(pointLight);

        // --- Selective Bloom Setup ---
        const ENTIRE_SCENE = 0, BLOOM_SCENE = 1;
        const bloomLayer = new THREE.Layers();
        bloomLayer.set(BLOOM_SCENE);

        const darkMaterial = new THREE.MeshBasicMaterial({ color: "black" });
        const materials = {};

        const renderPass = new RenderPass(scene, activeCamera);

        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 0.8; 
        bloomPass.radius = 0.2;

        const bloomComposer = new EffectComposer(renderer);
        bloomComposer.renderToScreen = false;
        bloomComposer.addPass(renderPass);
        bloomComposer.addPass(bloomPass);

        const finalPass = new ShaderPass(
            new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: { value: null },
                    bloomTexture: { value: bloomComposer.renderTarget2.texture }
                },
                vertexShader: document.getElementById('vertexshader')?.textContent,
                fragmentShader: document.getElementById('fragmentshader')?.textContent,
                defines: {}
            }), "baseTexture"
        );
        finalPass.needsSwap = true;

        const finalComposer = new EffectComposer(renderer);
        finalComposer.addPass(renderPass);
        finalComposer.addPass(finalPass);
        
        function createDiskGeometry(innerRadius, outerRadius, color1, color2) {
            const diskParticles = 15000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(diskParticles * 3);
            const colors = new Float32Array(diskParticles * 3);
            const colorInside = new THREE.Color(color1);
            const colorOutside = new THREE.Color(color2);
            for (let i = 0; i < diskParticles; i++) {
                const distance = THREE.MathUtils.randFloat(innerRadius, outerRadius);
                const angle = THREE.MathUtils.randFloat(0, 2 * Math.PI);
                positions[i * 3] = Math.cos(angle) * distance;
                positions[i * 3 + 1] = THREE.MathUtils.randFloat(-2.5, 2.5);
                positions[i * 3 + 2] = Math.sin(angle) * distance;
                const lerpFactor = (distance - innerRadius) / (outerRadius - innerRadius);
                const color = new THREE.Color().lerpColors(colorInside, colorOutside, lerpFactor);
                colors[i * 3] = color.r; colors[i * 3 + 1] = color.g; colors[i * 3 + 2] = color.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            return geometry;
        }

        const smbh = new THREE.Mesh(new THREE.CylinderGeometry(25, 25, 2, 64), new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                radius: { value: 25 },
                cameraPos: { value: new THREE.Vector3() }
            },
            vertexShader: document.getElementById('bh-vertexshader')?.textContent,
            fragmentShader: document.getElementById('bh-fragmentshader')?.textContent,
        }));
        const smbhData = { id: 'smbh', name: 'Supermassive BH', mesh: smbh, mass: 500000, radius: 25, velocity: new THREE.Vector3(), rotationSpeed: 0.0005 };
        blackHoles.push(smbhData);
        updateBlackHoleVisuals(smbhData);
        scene.add(smbh);

        const orbitingBh = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 2, 64), new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                radius: { value: 10 },
                cameraPos: { value: new THREE.Vector3() }
            },
            vertexShader: document.getElementById('bh-vertexshader')?.textContent,
            fragmentShader: document.getElementById('bh-fragmentshader')?.textContent,
        }));
        orbitingBh.position.set(400, 0, 0);
        scene.add(orbitingBh);
        const orbitalVelocity = Math.sqrt((state.gravityConstant * 500000) / 400);
        const orbitingBhData = { id: 'orbiting_bh', name: 'Orbiting BH', mesh: orbitingBh, mass: 100000, radius: 10, velocity: new THREE.Vector3(0, 0, -orbitalVelocity), rotationSpeed: 0.001 };
        blackHoles.push(orbitingBhData);
        updateBlackHoleVisuals(orbitingBhData);
        
        cameraTarget = blackHoles[0];

        const starfield = new THREE.Points(createStarfieldGeometry(), new THREE.PointsMaterial({ color: 0xffffff, size: 0.7 }));
        scene.add(starfield);

        function createStarfieldGeometry() {
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = [];
            for (let i = 0; i < 20000; i++) {
                starPositions.push(THREE.MathUtils.randFloatSpread(4000), THREE.MathUtils.randFloatSpread(4000), THREE.MathUtils.randFloatSpread(4000));
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
            return starGeometry;
        }

        const cannon = new THREE.Group();
        const barrelGroup = new THREE.Group();
        barrelGroup.position.y = 5;
        cannon.add(barrelGroup);
        cannon.position.set(0, -20, 550);
        scene.add(cannon);
        barrelGroup.add(cannonCamera);
        cannonCamera.position.set(0, 3.5, 12);

        const trajectoryLine = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7 }));
        trajectoryLine.frustumCulled = false;
        scene.add(trajectoryLine);

        function updateTrajectory() {
            const points = [];
            const steps = 200, timeStep = 0.5;
            const startPos = new THREE.Vector3(0, 0, -12.5);
            barrelGroup.localToWorld(startPos);
            const fireDirection = new THREE.Vector3();
            barrelGroup.getWorldDirection(fireDirection);
            fireDirection.negate();
            const startVel = fireDirection.clone().multiplyScalar(state.cannonPower);
            let currentPos = startPos.clone();
            let currentVel = startVel.clone();
            const mass = parseFloat(ui.massInput.value);
            for (let i = 0; i < steps; i++) {
                let totalForce = new THREE.Vector3();
                for (const bh of blackHoles) {
                    const distanceVec = new THREE.Vector3().subVectors(bh.mesh.position, currentPos);
                    const distanceSq = distanceVec.lengthSq();
                    if (distanceSq < bh.radius * bh.radius) { totalForce.set(0,0,0); break; }
                    const forceMagnitude = (state.gravityConstant * bh.mass * mass) / distanceSq;
                    totalForce.add(distanceVec.normalize().multiplyScalar(forceMagnitude));
                }
                if (totalForce.lengthSq() === 0) break;
                const acceleration = totalForce.divideScalar(mass);
                currentVel.add(acceleration.multiplyScalar(timeStep));
                currentPos.add(currentVel.clone().multiplyScalar(timeStep));
                points.push(currentPos.clone());
            }
            trajectoryLine.geometry.setFromPoints(points);
        }

        function createProjectile(position, velocity) {
            const options = objectTypes[ui.ammoSelect.value];
            const mass = parseFloat(ui.massInput.value);
            const projectileMaterial = new THREE.MeshStandardMaterial({
                color: options.color, 
                emissive: options.color,
                emissiveIntensity: options.emissiveIntensity,
                roughness: 0.8, 
                metalness: 0.2, 
                transparent: true
            });
            const projectile = new THREE.Mesh(new THREE.SphereGeometry(options.radius, 32, 32), projectileMaterial);
            projectile.layers.enable(BLOOM_SCENE);

            projectile.position.copy(position);
            scene.add(projectile);
            const newId = `obj_${state.objectIdCounter++}`;

            if (options.isBlackHole) {
                const newBh = { id: newId, name: 'Fired BH', mesh: projectile, mass: mass, radius: options.radius, velocity: velocity, rotationSpeed: 0.001 };
                blackHoles.push(newBh);
                updateBlackHoleVisuals(newBh);
            } else {
                const obj = { id: newId, name: options.name, mesh: projectile, velocity: velocity, mass: mass, originalColor: new THREE.Color(options.color), options: options };
                celestialObjects.push(obj);
                if (options.isStar) {
                    const starLight = new THREE.PointLight(options.color, 2, 800);
                    obj.light = starLight;
                    projectile.add(starLight);
                }
            }
            updateObjectCount();
            updateMassEditor();
        }
        
        function updatePhysics(delta) {
            for (let i = blackHoles.length - 1; i >= 0; i--) {
                const bh1 = blackHoles[i];
                let totalForce = new THREE.Vector3();
                for (let j = 0; j < blackHoles.length; j++) {
                    if (i === j) continue;
                    const bh2 = blackHoles[j];
                    const distanceVec = new THREE.Vector3().subVectors(bh2.mesh.position, bh1.mesh.position);
                    const distanceSq = distanceVec.lengthSq();
                    if (distanceSq < (bh1.radius + bh2.radius) * (bh1.radius + bh2.radius)) {
                        const bigger = bh1.mass > bh2.mass ? bh1 : bh2; const smaller = bh1.mass > bh2.mass ? bh2 : bh1;
                        const wasCameraTarget = smaller.id === cameraTarget.id;
                        const combinedMomentum = new THREE.Vector3().addScaledVector(bigger.velocity, bigger.mass).addScaledVector(smaller.velocity, smaller.mass);
                        bigger.mass += smaller.mass; bigger.velocity = combinedMomentum.divideScalar(bigger.mass);
                        const scaleFactor = Math.cbrt(bigger.mass / (bigger.mass - smaller.mass));
                        bigger.radius *= scaleFactor; bigger.mesh.scale.multiplyScalar(scaleFactor);
                        scene.remove(smaller.mesh);
                        const removedIndex = blackHoles.findIndex(bh => bh.id === smaller.id);
                        if (removedIndex > -1) blackHoles.splice(removedIndex, 1);
                        if (j < i) i--;
                        updateBlackHoleVisuals(bigger);
                        if (wasCameraTarget) updateCameraTarget();
                        updateMassEditor(); continue;
                    }
                    const forceMagnitude = (state.gravityConstant * bh1.mass * bh2.mass) / distanceSq;
                    totalForce.add(distanceVec.normalize().multiplyScalar(forceMagnitude));
                }
                const acceleration = totalForce.divideScalar(bh1.mass);
                bh1.velocity.add(acceleration.multiplyScalar(delta));
            }
            for (const bh of blackHoles) {
                bh.mesh.position.add(bh.velocity.clone().multiplyScalar(delta));
            }

            const redColor = new THREE.Color(0xff0000);
            for (let i = celestialObjects.length - 1; i >= 0; i--) {
                const obj = celestialObjects[i];
                let totalForce = new THREE.Vector3(), closestBh = null, closestDistSq = Infinity;
                for (const bh of blackHoles) {
                    const distanceVec = new THREE.Vector3().subVectors(bh.mesh.position, obj.mesh.position);
                    const distanceSq = distanceVec.lengthSq();
                    const forceMagnitude = (state.gravityConstant * bh.mass * obj.mass) / distanceSq;
                    totalForce.add(distanceVec.clone().normalize().multiplyScalar(forceMagnitude));
                    if (distanceSq < closestDistSq) { closestDistSq = distanceSq; closestBh = bh; }
                }
                
                const plungeStartDistSq = (closestBh.radius * 3) * (closestBh.radius * 3);
                if (closestDistSq < plungeStartDistSq) {
                    const plungeFactor = 1 - ((closestDistSq - (closestBh.radius*closestBh.radius)) / (plungeStartDistSq - (closestBh.radius*closestBh.radius)));
                    const clampedFactor = Math.min(1, Math.max(0, plungeFactor));
                    obj.mesh.lookAt(closestBh.mesh.position);
                    const stretch = 1 + clampedFactor * 15, squash = Math.max(0.01, 1 - clampedFactor * 0.9);
                    obj.mesh.scale.set(squash, stretch, squash);
                    obj.mesh.material.color.lerpColors(obj.originalColor, redColor, clampedFactor * 0.8);
                    obj.mesh.material.opacity = 1 - clampedFactor;
                    if (clampedFactor > 0.99) {
                        transitionQueue.push({ objectData: obj.options, entryTime: clock.getElapsedTime() });
                        if (obj.light) obj.mesh.remove(obj.light);
                        scene.remove(obj.mesh);
                        celestialObjects.splice(i, 1);
                        updateObjectCount(); updateMassEditor(); continue;
                    }
                }
                const acceleration = totalForce.divideScalar(obj.mass);
                obj.velocity.add(acceleration.multiplyScalar(delta));
                obj.mesh.position.add(obj.velocity.clone().multiplyScalar(delta));
            }

            for (let i = transitionQueue.length - 1; i >= 0; i--) {
                const item = transitionQueue[i];
                if (clock.getElapsedTime() - item.entryTime > 2) {
                    createWhiteHole(item.objectData);
                    transitionQueue.splice(i, 1);
                }
            }
            for (let i = whiteHoles.length - 1; i >= 0; i--) {
                const wh = whiteHoles[i];
                wh.lifetime -= delta;
                wh.mesh.material.opacity = Math.max(0, wh.lifetime / 2);
                if (wh.lifetime <= 0) { scene.remove(wh.mesh); whiteHoles.splice(i, 1); }
            }
        }

        function createWhiteHole(objectData) {
            const position = new THREE.Vector3(THREE.MathUtils.randFloatSpread(1000), THREE.MathUtils.randFloatSpread(1000), THREE.MathUtils.randFloatSpread(1000));
            const whMesh = new THREE.Mesh(new THREE.SphereGeometry(15, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending }));
            whMesh.position.copy(position);
            whMesh.layers.enable(BLOOM_SCENE);
            scene.add(whMesh);
            whiteHoles.push({ mesh: whMesh, lifetime: 2.0 });
            const projectile = new THREE.Mesh(new THREE.SphereGeometry(objectData.radius, 32, 32), new THREE.MeshStandardMaterial({color: objectData.color, emissive: objectData.color, emissiveIntensity: objectData.emissiveIntensity, roughness: 0.8, metalness: 0.2}));
            projectile.position.copy(position);
            projectile.layers.enable(BLOOM_SCENE);
            scene.add(projectile);
            const velocity = new THREE.Vector3().randomDirection().multiplyScalar(150);
            const obj = { id: `obj_${state.objectIdCounter++}`, name: objectData.name, mesh: projectile, velocity: velocity, mass: objectData.mass, originalColor: new THREE.Color(objectData.color), options: objectData };
            celestialObjects.push(obj);
            if (objectData.isStar) {
                const starLight = new THREE.PointLight(objectData.color, 2, 800);
                obj.light = starLight;
                projectile.add(starLight);
            }
            updateObjectCount(); updateMassEditor();
        }

        const ui = {
            gravitySlider: document.getElementById('gravity-slider'), gravityInput: document.getElementById('gravity-input'),
            powerSlider: document.getElementById('power-slider'), powerInput: document.getElementById('power-input'),
            massSlider: document.getElementById('mass-slider'), massInput: document.getElementById('mass-input'),
            ammoSelect: document.getElementById('ammo-select'), objectCountEl: document.getElementById('object-count-info'),
            controlsInfoEl: document.getElementById('controls-info'), crosshair: document.getElementById('crosshair'),
            mainControls: document.getElementById('main-controls-container'), mobileControls: document.getElementById('mobile-controls'),
            toggleAimBtn: document.getElementById('toggle-aim-mode-btn'), massEditorContent: document.getElementById('mass-editor-content'),
            toggleControlsBtn: document.getElementById('toggle-controls-btn'), collapsibleControls: document.getElementById('collapsible-controls'),
            prevAmmoBtn: document.getElementById('prev-ammo-btn'), nextAmmoBtn: document.getElementById('next-ammo-btn'),
            currentAmmoName: document.getElementById('current-ammo-name'),
            mainFireBtn: document.getElementById('main-fire-btn')
        };

        function updateObjectCount() { ui.objectCountEl.textContent = `Objects: ${(celestialObjects.length + blackHoles.length - 2)}`; }

        function updateMassEditor() {
            if (state.isMobile) return;
            ui.massEditorContent.innerHTML = '';
            const allObjects = [...blackHoles, ...celestialObjects];
            allObjects.forEach(obj => {
                const li = document.createElement('div');
                li.className = 'flex items-center justify-between mb-2 text-sm';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${obj.name} ${obj.id.startsWith('obj_') ? obj.id.split('_')[1] : ''}`;
                const massInput = document.createElement('input');
                massInput.type = 'number';
                massInput.value = obj.mass.toFixed(0);
                massInput.className = 'w-24 bg-gray-800 border border-gray-600 text-white rounded-md p-1 text-center';
                massInput.addEventListener('change', (e) => {
                    const newMass = parseFloat(e.target.value);
                    if (!isNaN(newMass) && newMass > 0) obj.mass = newMass;
                });
                li.appendChild(nameSpan); li.appendChild(massInput);
                ui.massEditorContent.appendChild(li);
            });
        }

        function setCameraMode(mode) {
            state.cameraMode = mode;
            if (mode === 'aiming') {
                activeCamera = cannonCamera; ui.crosshair.style.display = 'block';
                ui.mainControls.style.opacity = '0.5';
                if (state.isMobile) {
                    ui.mobileControls.style.display = 'flex';
                    setTimeout(() => ui.mobileControls.classList.add('visible'), 50);
                    ui.toggleAimBtn.textContent = 'Exit';
                    ui.controlsInfoEl.textContent = 'Use joysticks to aim and move.';
                } else {
                    renderer.domElement.requestPointerLock();
                    ui.controlsInfoEl.textContent = 'WASD/Mouse | Click to Fire | Esc to Exit';
                }
            } else {
                activeCamera = cinematicCamera; ui.crosshair.style.display = 'none';
                ui.mainControls.style.opacity = '1';
                if (state.isMobile) {
                    ui.mobileControls.classList.remove('visible');
                    setTimeout(() => ui.mobileControls.style.display = 'none', 400);
                    ui.toggleAimBtn.textContent = 'Aim';
                    ui.controlsInfoEl.textContent = 'Tap "Aim" to control cannon.';
                } else {
                    if(document.pointerLockElement) document.exitPointerLock();
                    ui.controlsInfoEl.textContent = 'Click simulation to aim.';
                }
            }
            renderPass.camera = activeCamera;
        }

        renderer.domElement.addEventListener('click', (e) => {
            if (e.target.closest('.controls-panel') || state.cameraMode === 'aiming') return;
            const rect = renderer.domElement.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
            const mouse = new THREE.Vector2(x, y);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, activeCamera);
            const point = new THREE.Vector3();
            raycaster.ray.at(500, point);
            const startPos = new THREE.Vector3();
            activeCamera.getWorldPosition(startPos);
            const velocity = new THREE.Vector3().subVectors(point, startPos).normalize().multiplyScalar(state.cannonPower);
            createProjectile(startPos, velocity);
        });

        document.addEventListener('pointerlockchange', () => { if (!state.isMobile && document.pointerLockElement !== renderer.domElement && state.cameraMode === 'aiming') setCameraMode('cinematic'); });
        document.addEventListener('keydown', (e) => { state.keyState[e.code] = true; });
        document.addEventListener('keyup', (e) => { state.keyState[e.code] = false; });
        document.addEventListener('mousemove', (e) => { if (state.cameraMode !== 'aiming' || state.isMobile) return; cannon.rotation.y -= e.movementX * 0.002; barrelGroup.rotation.x = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, barrelGroup.rotation.x - e.movementY * 0.002)); });
        document.addEventListener('mousedown', (e) => { if (state.cameraMode === 'aiming' && !state.isMobile && e.button === 0) createProjectile(cannonCamera.position, cannonCamera.getWorldDirection(new THREE.Vector3()).multiplyScalar(state.cannonPower)); });
        document.addEventListener('wheel', (e) => { if (state.cameraMode !== 'aiming' || state.isMobile) return; let currentIndex = ui.ammoSelect.selectedIndex; currentIndex += Math.sign(e.deltaY); if (currentIndex < 0) currentIndex = ui.ammoSelect.options.length - 1; else if (currentIndex >= ui.ammoSelect.options.length) currentIndex = 0; ui.ammoSelect.selectedIndex = currentIndex; });
        ui.mainFireBtn.addEventListener('click', () => {
            const startPos = new THREE.Vector3(0, 0, -12.5);
            barrelGroup.localToWorld(startPos);
            const targetBh = blackHoles[0];
            const toBh = new THREE.Vector3().subVectors(targetBh.mesh.position, startPos).normalize();
            const up = new THREE.Vector3(0, 1, 0);
            let perp = new THREE.Vector3().crossVectors(toBh, up).normalize();
            if (perp.lengthSq() < 0.01) { perp.set(1, 0, 0); }
            perp.applyAxisAngle(toBh, Math.random() * Math.PI * 2);
            perp.multiplyScalar(0.3 + Math.random() * 1.2);
            const fireDirection = toBh.clone().add(perp).normalize();
            const velocity = fireDirection.clone().multiplyScalar(state.cannonPower);
            createProjectile(startPos, velocity);
        });
        ui.toggleAimBtn.addEventListener('click', (e) => { e.stopPropagation(); setCameraMode(state.cameraMode === 'cinematic' ? 'aiming' : 'cinematic'); });

        function setupJoystick(elementId, onMove) {
            const container = document.getElementById(elementId); if (!container) return;
            const handle = container.querySelector('.joystick-handle');
            let activeTouchId = null, rect;
            const updateRect = () => { rect = container.getBoundingClientRect(); };
            updateRect(); window.addEventListener('resize', updateRect);
            container.addEventListener('touchstart', (e) => { e.preventDefault(); if (activeTouchId === null) { activeTouchId = e.changedTouches[0].identifier; updateRect(); } }, { passive: false });
            container.addEventListener('touchmove', (e) => { e.preventDefault(); for (let touch of e.changedTouches) { if (touch.identifier === activeTouchId) { const center = { x: rect.width / 2, y: rect.height / 2 }; let x = touch.clientX - rect.left, y = touch.clientY - rect.top; let deltaX = x - center.x, deltaY = y - center.y; let distance = Math.sqrt(deltaX*deltaX + deltaY*deltaY); let maxDist = center.x; if (distance > maxDist) { deltaX = (deltaX / distance) * maxDist; deltaY = (deltaY / distance) * maxDist; } handle.style.transform = `translate(${deltaX}px, ${deltaY}px)`; onMove(deltaX / maxDist, deltaY / maxDist); } } }, { passive: false });
            const endTouch = (e) => { for (let touch of e.changedTouches) { if (touch.identifier === activeTouchId) { activeTouchId = null; handle.style.transform = 'translate(-50%, -50%)'; onMove(0, 0); break; } } };
            container.addEventListener('touchend', endTouch); container.addEventListener('touchcancel', endTouch);
        }

        let moveInput = { x: 0, y: 0 }, aimInput = { x: 0, y: 0 };
        if (state.isMobile) {
            setupJoystick('joystick-move', (x, y) => { moveInput = { x, y }; });
            setupJoystick('joystick-aim', (x, y) => { aimInput = { x, y }; });
            document.getElementById('mobile-fire-button').addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); createProjectile(cannonCamera.position, cannonCamera.getWorldDirection(new THREE.Vector3()).multiplyScalar(state.cannonPower)); }, { passive: false });
        }

        ui.gravitySlider.addEventListener('input', (e) => { ui.gravityInput.value = e.target.value; updateGravity(parseFloat(e.target.value)); });
        ui.gravityInput.addEventListener('change', (e) => { ui.gravitySlider.value = e.target.value; updateGravity(parseFloat(e.target.value)); });
        ui.powerSlider.addEventListener('input', (e) => { ui.powerInput.value = e.target.value; state.cannonPower = parseFloat(e.target.value); });
        ui.powerInput.addEventListener('change', (e) => { ui.powerSlider.value = e.target.value; state.cannonPower = parseFloat(e.target.value); });
        ui.massSlider.addEventListener('input', (e) => { ui.massInput.value = e.target.value; });
        ui.massInput.addEventListener('change', (e) => { ui.massSlider.value = e.target.value; });
        
        document.getElementById('clear-btn').addEventListener('click', () => {
            location.reload();
        });

        if (state.isMobile) {
            ui.collapsibleControls.classList.add('collapsed');
            ui.toggleControlsBtn.textContent = 'Show';
        }

        ui.toggleControlsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isCollapsed = ui.collapsibleControls.classList.toggle('collapsed');
            ui.toggleControlsBtn.textContent = isCollapsed ? 'Show' : 'Hide';
        });

        function updateAmmoUI() {
            const selectedOption = ui.ammoSelect.options[ui.ammoSelect.selectedIndex];
            ui.currentAmmoName.textContent = selectedOption.text;
            updateMassControls();
        }

        function updateMassControls() {
            const selectedType = objectTypes[ui.ammoSelect.value];
            ui.massSlider.min = selectedType.minMass;
            ui.massSlider.max = selectedType.maxMass;
            ui.massSlider.value = selectedType.mass;
            ui.massInput.min = selectedType.minMass;
            ui.massInput.max = selectedType.maxMass;
            ui.massInput.value = selectedType.mass;
        }
        
        function updateCameraTarget() {
            if (blackHoles.length > 0) {
                blackHoles.sort((a, b) => b.mass - a.mass);
                cameraTarget = blackHoles[0];
                targetOrbitRadius = 600 + cameraTarget.radius * 10;
            } else {
                cameraTarget = { mesh: new THREE.Object3D() }; 
            }
        }

        ui.ammoSelect.addEventListener('change', updateAmmoUI);
        ui.prevAmmoBtn.addEventListener('click', () => {
            ui.ammoSelect.selectedIndex = (ui.ammoSelect.selectedIndex - 1 + ui.ammoSelect.options.length) % ui.ammoSelect.options.length;
            updateAmmoUI();
        });
        ui.nextAmmoBtn.addEventListener('click', () => {
            ui.ammoSelect.selectedIndex = (ui.ammoSelect.selectedIndex + 1) % ui.ammoSelect.options.length;
            updateAmmoUI();
        });

        function updateGravity(newGravity) {
            if (isNaN(newGravity) || newGravity <= 0) return;
            const scaleFactor = Math.sqrt(newGravity / state.lastGravityConstant);
            [...blackHoles, ...celestialObjects].forEach(obj => obj.velocity.multiplyScalar(scaleFactor));
            state.gravityConstant = newGravity;
            state.lastGravityConstant = newGravity > 0 ? newGravity : 0.1;
        }

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            cinematicCamera.aspect = aspect; cinematicCamera.updateProjectionMatrix();
            cannonCamera.aspect = aspect; cannonCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            bloomComposer.setSize(window.innerWidth, window.innerHeight);
            finalComposer.setSize(window.innerWidth, window.innerHeight);
        });

        function darkenNonBloomed(obj) {
            if ((obj.isMesh || obj.isPoints) && bloomLayer.test(obj.layers) === false) {
                materials[obj.uuid] = obj.material;
                obj.material = darkMaterial;
            }
        }
        
        function restoreMaterials(obj) {
            if (materials[obj.uuid]) {
                obj.material = materials[obj.uuid];
                delete materials[obj.uuid];
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(0.05, clock.getDelta());
            const elapsedTime = clock.getElapsedTime();
            if (state.cameraMode === 'cinematic') {
                const time = elapsedTime * 0.08;
                currentOrbitRadius = THREE.MathUtils.lerp(currentOrbitRadius, targetOrbitRadius, 0.05);
                const offsetX = Math.sin(time * 0.7) * currentOrbitRadius;
                const offsetY = Math.cos(time * 0.5) * (currentOrbitRadius * 0.6);
                const offsetZ = Math.cos(time * 0.9) * currentOrbitRadius;
                cinematicCamera.position.copy(cameraTarget.mesh.position).add(new THREE.Vector3(offsetX, offsetY, offsetZ));
                cinematicCamera.lookAt(cameraTarget.mesh.position);
            }
            updateCannon(delta);
            
            blackHoles.forEach(bh => {
                if (bh.mesh.children.length > 0 && bh.mesh.children[0].isPoints) {
                    bh.mesh.children[0].rotation.y += bh.rotationSpeed;
                }
                if(bh.mesh.material.uniforms) {
                    bh.mesh.material.uniforms.time.value = elapsedTime;
                    bh.mesh.material.uniforms.cameraPos.value.copy(activeCamera.position);
                }
            });

            updatePhysics(delta);
            if(trajectoryLine) {
                if(state.cameraMode === 'aiming') updateTrajectory();
                trajectoryLine.visible = state.cameraMode === 'aiming' && state.canFire;
            }

            // Selective bloom rendering
            scene.traverse(darkenNonBloomed);
            bloomComposer.render();
            scene.traverse(restoreMaterials);
            finalComposer.render();
        }
        
        function updateCannon(delta) {
            const moveSpeed = 100 * delta, aimSpeed = 1.5 * delta;
            const forward = new THREE.Vector3(), right = new THREE.Vector3();
            cannon.getWorldDirection(forward);
            right.crossVectors(cannon.up, forward);
            if (state.cameraMode === 'aiming') {
                if (state.isMobile) {
                    if (moveInput.y !== 0) cannon.position.addScaledVector(forward, -moveInput.y * moveSpeed);
                    if (moveInput.x !== 0) cannon.position.addScaledVector(right, moveInput.x * moveSpeed);
                    cannon.rotation.y -= aimInput.x * aimSpeed;
                    barrelGroup.rotation.x = Math.max(-Math.PI / 2 + 0.2, Math.min(Math.PI / 2 - 0.2, barrelGroup.rotation.x - aimInput.y * aimSpeed));
                } else {
                    if (state.keyState['KeyW']) cannon.position.addScaledVector(forward, moveSpeed);
                    if (state.keyState['KeyS']) cannon.position.addScaledVector(forward, -moveSpeed);
                    if (state.keyState['KeyA']) cannon.position.addScaledVector(right, -moveSpeed);
                    if (state.keyState['KeyD']) cannon.position.addScaledVector(right, moveSpeed);
                }
            }
        }

        function updateBlackHoleVisuals(bh) {
            if (bh.mesh.children.length > 0) {
                bh.mesh.remove(bh.mesh.children[0]);
            }

            const massRatio = Math.min(1, (bh.mass - 100000) / 1000000); 

            const color1 = new THREE.Color(0xffa500).lerp(new THREE.Color(0x00aaff), massRatio);
            const color2 = new THREE.Color(0x8B0000).lerp(new THREE.Color(0x9400D3), massRatio);
            
            const highMassColor1 = new THREE.Color(0x00aaff).lerp(new THREE.Color(0xFFFFFF), massRatio * 2 - 1);
            const highMassColor2 = new THREE.Color(0x9400D3).lerp(new THREE.Color(0x00FFFF), massRatio * 2 - 1);

            color1.lerp(highMassColor1, massRatio > 0.5 ? 1 : 0);
            color2.lerp(highMassColor2, massRatio > 0.5 ? 1 : 0);

            const diskGeometry = createDiskGeometry(bh.radius + 5, bh.radius + 60, color1, color2);
            const disk = new THREE.Points(diskGeometry, new THREE.PointsMaterial({ size: 0.5, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8, depthWrite: false }));
            bh.mesh.add(disk);
            bh.rotationSpeed = 0.0005 + massRatio * 0.005;
        }

        setCameraMode('cinematic');
        updateObjectCount();
        updateMassEditor();
        updateAmmoUI();
        animate();
    </script>
    <script id="vertexshader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentshader" type="x-shader/x-fragment">
        uniform sampler2D baseTexture;
        uniform sampler2D bloomTexture;
        varying vec2 vUv;
        void main() {
            gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );
        }
    </script>
    <script id="bh-vertexshader" type="x-shader/x-vertex">
        uniform float time;
        uniform float radius;
        uniform vec3 cameraPos;
        varying vec3 vNormal;
        varying vec3 vViewDir;

        void main() {
            vNormal = normal;
            vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;
            vViewDir = normalize(cameraPos - worldPos);

            float dist = length(position.xz);
            float angle = atan(position.z, position.x);
            float vortex = pow(dist / radius, 2.0) * -10.0;
            vortex *= sin(dist / radius * 3.14159 * 2.0 + time * 2.0);

            vec3 spherePos = normalize(position) * radius;
            
            float viewFactor = 1.0 - abs(dot(normalize(cameraPos - worldPos), (modelMatrix * vec4(normal, 0.0)).xyz));
            
            vec3 finalPos = mix(spherePos, vec3(position.x, vortex, position.z), viewFactor);

            gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);
        }
    </script>
    <script id="bh-fragmentshader" type="x-shader/x-fragment">
        uniform sampler2D baseTexture;
        varying vec3 vViewDir;
        varying vec3 vNormal;

        void main() {
            vec3 reflected = reflect(vViewDir, vNormal);
            vec2 uv = vec2(atan(reflected.z, reflected.x), acos(reflected.y) / 3.14159);
            gl_FragColor = texture2D(baseTexture, uv);
        }
    </script>
</body>
</html>
